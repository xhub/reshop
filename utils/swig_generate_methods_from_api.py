#!/usr/bin/env python

import copy
import csv
import itertools
import json
from pathlib import Path
import sys
from typing import NamedTuple


def usage():
    print("ERROR: need to have the json file from clang given as lone argument\n")
    print("\nGenerate it with: clang -Xclang -ast-dump=json -fsyntax-only /path/to/reshop.h > /path/to/reshop-API-ast.json\n")
    exit(1)


class PyObj(NamedTuple):
    cname: str            # C name
    pyname: str           # python name
    fn_prefixes: tuple    # Format: (C name, python name)
    fn_ignore: tuple

class FnDecl(NamedTuple):
    ret_type: str
    name: str
    args: str
    args_nameonly: str
    cret_type: str
    cname: str
    cargs: str



# FIXME: backup
#pyObjs = {
#    "Model": PyObj("struct rhp_mdl", ("rhp_mdl_", "rhp_"), ("rhp_mdl_free","rhp_mdl_getmpforvar","rhp_mdl_getmpforequ")),
##    "Avar": PyObj("struct rhp_avar"),
##    "Aequ": PyObj("struct rhp_aequ"),
#    "MathPrgm": PyObj("struct rhp_mathprgm", ("rhp_mp_",), ("rhp_mp_free",)),
#    "NashEquilibrium": PyObj("struct rhp_nash_equilibrium", ("rhp_mpe_", "rhp_nash_"), ("rhp_mpe_free",)),
#}

pyObjs = {
    "Model": PyObj("rhp_mdl_t", "struct rhp_mdl", ("rhp_mdl_", "rhp_"), ("rhp_mdl_free","rhp_mdl_getmpforvar","rhp_mdl_getmpforequ")),
#    "Avar": PyObj("struct rhp_avar"),
#    "Aequ": PyObj("struct rhp_aequ"),
    "MathPrgm": PyObj("rhp_mathprgm_t", "struct rhp_mathprgm", ("rhp_mp_", "struct rhp_mathprgm"), ()),
    "NashEquilibrium": PyObj("rhp_nash_equilibrium_t", "struct rhp_nash_equilibrium", ("rhp_nash_","struct rhp_nash_equilibrium"), ()),
}

pyMethodsRc = dict(zip(pyObjs.keys(), tuple([] for _ in range(len(pyObjs.keys())))))

pyMethodsRet = dict(zip(pyObjs.keys(), tuple([] for _ in range(len(pyObjs.keys())))))

# print is a python keyword
# solve is manually defined
methods_skips = ("print", "solve")

rename_ret = {"rhp_mathprgm_getobjequ": "rhp_idx", "rhp_mathprgm_getobjequ": "rhp_idx"}
rhp_idx_names = ("ei", "vi", "objequ", "objvar")

reshop_ignore = ["rhp_empdag_writeDOT"]

script = Path(sys.argv[0])
with open(script.parent.joinpath("reshop_generators_config.csv"), "r") as f:
    reader = csv.reader(f)

    for row in reader:
        if row and row[0]:
            reshop_ignore.append(row[0])


if len (sys.argv) != 2:
    usage()

with open(sys.argv[1], 'r') as f:
     ast_data = json.load(f)


for pyObj, v in pyObjs.items():
    cname = v.cname
    fn_prefixes = v.fn_prefixes
    methods_rc = pyMethodsRc[pyObj]
    methods_ret = pyMethodsRet[pyObj]
    fn_ignore = copy.deepcopy(reshop_ignore)
    fn_ignore.extend(v.fn_ignore)
    for decl in ast_data['inner']:
        if decl['kind'] != 'FunctionDecl': continue

        inner = decl.get("inner")
        if not inner: continue

        name = decl["name"]

        if name in fn_ignore: continue
        fnargs = tuple(e for e in inner if e["kind"] == "ParmVarDecl")

        if not len(fnargs): continue

        first_arg = fnargs[0]

        if not cname in first_arg['type']['qualType']: continue

        # rhp_idx is useful for typemaps, reinject it
        fnargs_post = []
        for arg in fnargs:
            if arg['name'] in rhp_idx_names:
                arg['type']['qualType'] = arg['type']['qualType'].replace("int", "rhp_idx")

            fnargs_post.append(arg)

        fnargs = fnargs_post

        args = (f"{e['type']['qualType']} {e['name']}" for e in fnargs[1:])


        method_name = name
        for prefix in fn_prefixes:
            method_name = method_name.replace(prefix, "")

        if method_name in methods_skips: continue

        method_args = ", ".join(args)
        methods_argsnameonly = ", ".join(f"{e['name']}" for e in fnargs[1:])

        ret_type = decl['type']['qualType'].split('(')[0].strip()

        # reinject rhp_idx
        ret_type:str = rename_ret.get(name, ret_type)

        if ret_type == "int":
            methods_rc.append(FnDecl(ret_type, method_name, method_args, methods_argsnameonly, ret_type, name, method_args))
        else:
            methods_ret.append(FnDecl(ret_type, method_name, method_args, methods_argsnameonly, ret_type, name, method_args))


need_defines = []
for m in itertools.chain(pyMethodsRc["Model"], pyMethodsRet["Model"]):
    if "rhp_mdl_" not in m.cname:
        need_defines.append(f"#define {m.cname.replace("rhp_", "rhp_mdl_")} {m.cname}")

for m in itertools.chain(pyMethodsRc["MathPrgm"], pyMethodsRet["MathPrgm"]):
    need_defines.append(f"#define {m.cname.replace("rhp_mp_", "rhp_mathprgm_")} {m.cname}")

for m in itertools.chain(pyMethodsRc["NashEquilibrium"], pyMethodsRet["NashEquilibrium"]):
    need_defines.append(f"#define {m.cname.replace("rhp_nash_", "rhp_nash_equilibrium_")} {m.cname}")


print("Starting generation")

with open(Path("generated").joinpath("pyobj_methods.i"), "w") as method_file:
    method_file.write(f"// Generated by {Path(sys.argv[0]).name}\n\n")

    for pyObj, v in pyObjs.items():
        method_file.write(f"%extend {v.pyname} {{\n")

        for m in pyMethodsRc[pyObj]:
            if m.cargs:
                cargs = ", " + m.cargs
                margs = m.cargs
                margs_nameonly = ", " + m.args_nameonly
            else:
                cargs = ""
                margs = "void"
                margs_nameonly = ""

            if m.cname.endswith("named"):
                # rename last argument (name)
                fnname = m.name.replace("_named", "").replace("named", "")
                method_file.write(f"\t{m.ret_type} {fnname}({margs}) {{ return {m.cname} (self{margs_nameonly}); }};\n")
            else:
                method_file.write(f"\t{m.ret_type} {m.name}({margs});\n")

        for m in pyMethodsRet[pyObj]:
            if m.cargs:
                cargs = ", " + m.cargs
                margs = m.cargs
            else:
                cargs = ""
                margs = "void"
            method_file.write(f"\t{m.ret_type} {m.name}({margs});\n")

        method_file.write("}\n")


    if not need_defines: sys.exit(0)

    method_file.write("%header %{\n")
    for d in need_defines:
        method_file.write(d + "\n")

    method_file.write("%}\n")


with open(Path("generated").joinpath("rename_named.i"), "w") as rename_file:
    rename_file.write(f"// Generated by {Path(sys.argv[0]).name}\n\n")
    for m in itertools.chain((v for v in itertools.chain(*pyMethodsRc.values(), *pyMethodsRet.values()))):
        if m.cname.endswith("named"):
            rename_file.write(f"%rename({m.cname.replace("_named", "").replace("named", "").replace("rhp_","")}) {m.cname};\n")


with open(Path("generated").joinpath("pyobj_methods_docstring.i.in"), "w") as docstring_file:
    docstring_file.write(f"// Generated by {Path(sys.argv[0]).name}\n\n")
    for pyMethods in (pyMethodsRc, pyMethodsRet):
        for obj, methods in pyMethods.items():
            for method in methods:
                if method.cname.endswith("named"): continue
                pyobj = pyObjs[obj]
                docstring_file.write(f'%feature("docstring") {pyobj.pyname.split()[-1]}::{method.name} "{{fndecls[{method.cname}]}}";\n')


print("Successful generation!")
