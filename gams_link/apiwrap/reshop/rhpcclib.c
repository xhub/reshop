/*  C library code generated by apiwrapper for GAMS Version 24.9.0 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#include "rhp.h"

#if defined(_WIN32)
# define RHP_API __declspec(dllexport)
# define RHP_CALLCONV __stdcall
#elif defined(__GNUC__)
# define RHP_API __attribute__((__visibility__("default")))
# define RHP_CALLCONV
#else
# define RHP_API
# define RHP_CALLCONV
#endif

#ifndef APICHECKONLY
#define XCreate xcreate
#define XFree xfree
#define C__XAPIVersion c__xapiversion
#define D__XAPIVersion d__xapiversion
#define C__XCheck c__xcheck
#define D__XCheck d__xcheck
#define rhpXCreate rhpxcreate
#define rhpXFree rhpxfree
#define D__rhpXAPIVersion d__rhpxapiversion
#define D__rhpXCheck d__rhpxcheck
#define C__rhpCallSolver c__rhpcallsolver
#define C__rhpReadyAPI c__rhpreadyapi

/* declarations shut up compiler warnings */
RHP_API void RHP_CALLCONV XCreate (rhpRec_t **rhp);
RHP_API void RHP_CALLCONV XCreate (rhpRec_t **rhp)
{
  char Msg_sst[256];
  rhpCreate(rhp, Msg_sst, sizeof(Msg_sst));
} /* XCreate */

RHP_API int RHP_CALLCONV rhpcreate (rhpRec_t **rhp, char *msgBuf, int msgBufLen);
RHP_API int RHP_CALLCONV rhpcreate (rhpRec_t **rhp, char *msgBuf, int msgBufLen)
{
  assert(NULL != rhp);
  *rhp = NULL;
  XCreate (rhp);
  if (NULL == *rhp) {
    strncpy (msgBuf, "Error while creating object", msgBufLen);
    if (msgBufLen > 0)
      msgBuf[msgBufLen-1] = '\0';
    return 0;
  }
  else {
    if (msgBufLen > 0)
      msgBuf[0] = '\0';
    return 1;
  }
} /* rhpcreate */

RHP_API void RHP_CALLCONV rhpXCreate (rhpRec_t **rhp);
RHP_API void RHP_CALLCONV rhpXCreate (rhpRec_t **rhp)
{
  XCreate(rhp);
} /* rhpXCreate */

RHP_API void RHP_CALLCONV XFree (rhpRec_t **rhp);
RHP_API void RHP_CALLCONV XFree (rhpRec_t **rhp)
{
  if (*rhp != NULL)
  {
    rhpFree(rhp);
  }
} /* XFree */

RHP_API int RHP_CALLCONV rhpfree (rhpRec_t **rhp);
RHP_API int RHP_CALLCONV rhpfree (rhpRec_t **rhp)
{
  XFree (rhp);
  if (NULL == *rhp)
    return 1;
  else
    return 0;
} /* rhpfree */

RHP_API void RHP_CALLCONV rhpXFree (rhpRec_t **rhp);
RHP_API void RHP_CALLCONV rhpXFree (rhpRec_t **rhp)
{
  XFree(rhp);
} /* rhpXFree */

#endif

/* comp returns the compatibility mode:
   0: client is too old for the DLL, no compatibility
   1: client version and DLL version are the same, full compatibility
   2: client is older than DLL, but defined as compatible, backward compatibility
   3: client is newer than DLL, forward compatibility                              */
RHP_API int RHP_CALLCONV C__XAPIVersion(int api, char *Msg, int *comp);
RHP_API int RHP_CALLCONV C__XAPIVersion(int api, char *Msg, int *comp)
{
  *comp = 0;
  if (api >= 1) {
    if (api == 1) {
      *comp = 1;
      strcpy(Msg,"rhpcclib: Client version and DLL version are the same.");
    }
    else {
      *comp = 3;
      strcpy(Msg,"rhpcclib: Client version is newer than this DLL.");
    }
    return 1;
  }
  if (api == 1) {
    *comp = 2;
    strcpy(Msg,"rhpcclib: Client version is compatible to this version of the DLL.");
    return 1;
  }
  sprintf(Msg,"rhpcclib: The API is too old for the used library, API version: %d, library version: 1",api);
  return 0;
} /* C__XAPIVersion */

RHP_API int RHP_CALLCONV D__XAPIVersion(int api, char *Msg, int *comp);
RHP_API int RHP_CALLCONV D__XAPIVersion(int api, char *Msg, int *comp)
{
  int XAPIVersion_result;
  char Msg_sst[256];
  char *Msg_local;

  Msg_sst[0] = '\0';
  XAPIVersion_result = C__XAPIVersion(api,Msg_sst,comp);
  Msg_local = Msg+1;
  strncpy(Msg_local,Msg_sst,(strlen(Msg_sst)>254?254:strlen(Msg_sst)));
  Msg[0] = strlen(Msg_sst);
  return XAPIVersion_result;
} /* D__XAPIVersion */

RHP_API int RHP_CALLCONV D__rhpXAPIVersion(int api, char *Msg, int *comp);
RHP_API int RHP_CALLCONV D__rhpXAPIVersion(int api, char *Msg, int *comp)
{
  return D__XAPIVersion(api, Msg, comp);
} /* D__rhpXAPIVersion */

static int CheckSign(const char *funcn, int DLLNrArg, int ClNrArg, int DLLsign[], int Clsign[], char *Msg)
{
  int i;

  Msg[0] = '\0';
  if(DLLNrArg != ClNrArg)
  {
    sprintf(Msg,"rhpcclib: %s has wrong number of arguments.",funcn);
    return 0;
  }
  else
  {
    for(i=0;i<=DLLNrArg;i++)
    {
      if(DLLsign[i] != Clsign[i])
      {
        sprintf(Msg,"rhpcclib: %s has wrong argument types.",funcn);
        return 0;
      }
    }
  }
  return 1;
} /* CheckSign */

RHP_API int RHP_CALLCONV C__XCheck(const char *funcn, int ClNrArg, int Clsign[], char *Msg);
RHP_API int RHP_CALLCONV C__XCheck(const char *funcn, int ClNrArg, int Clsign[], char *Msg)
{
  int DLLsign[3];
  if(!strcmp(funcn,"rhpCallSolver"))
  {
    DLLsign[0] = 3;
    return CheckSign(funcn,0,ClNrArg,DLLsign,Clsign,Msg);
  }
  else if(!strcmp(funcn,"rhpReadyAPI"))
  {
    DLLsign[0] = 3;DLLsign[1] = 1;DLLsign[2] = 1;
    return CheckSign(funcn,2,ClNrArg,DLLsign,Clsign,Msg);
  }
  else
  {
    sprintf(Msg,"rhpcclib: %s cannot be found in library.",funcn);
    return 0;
  }
} /* C__XCheck */

RHP_API int RHP_CALLCONV D__XCheck(const unsigned char *funcn, int ClNrArg, int Clsign[], char *Msg);
RHP_API int RHP_CALLCONV D__XCheck(const unsigned char *funcn, int ClNrArg, int Clsign[], char *Msg)
{
  int XCheck_result;
  char funcn_sst[256];
  char Msg_sst[256];
  char *Msg_local;

  strncpy(funcn_sst,(const char *)funcn+1,funcn[0]);
  funcn_sst[funcn[0]] = '\0';
  XCheck_result = C__XCheck(funcn_sst,ClNrArg,Clsign,Msg_sst);
  Msg_local = Msg+1;
  strncpy(Msg_local,Msg_sst,(strlen(Msg_sst)>=255?254:strlen(Msg_sst)));
  Msg[0] = strlen(Msg_sst);
  return XCheck_result;
} /* D__XCheck */

RHP_API int RHP_CALLCONV D__rhpXCheck(const unsigned char *funcn, int ClNrArg, int Clsign[], char *Msg);
RHP_API int RHP_CALLCONV D__rhpXCheck(const unsigned char *funcn, int ClNrArg, int Clsign[], char *Msg)
{
  return D__XCheck(funcn, ClNrArg, Clsign, Msg);
} /* D__rhpXCheck */


#ifndef APICHECKONLY

RHP_API int  RHP_CALLCONV C__rhpCallSolver(rhpRec_t *rhp);
RHP_API int  RHP_CALLCONV C__rhpCallSolver(rhpRec_t *rhp)
{
  return rhpCallSolver(rhp);
}

RHP_API int  RHP_CALLCONV C__rhpReadyAPI(rhpRec_t *rhp,void *gmo,void *opt);
RHP_API int  RHP_CALLCONV C__rhpReadyAPI(rhpRec_t *rhp,void *gmo,void *opt)
{
  return rhpReadyAPI(rhp,gmo,opt);
}


#endif
